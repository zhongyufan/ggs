<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ES6</title>
</head>

<body>
    <!-- let、const -->
    <script>
        // {} 快作用域 let作用于块级作用域
        // {
        //     var a = 1;
        //     let b = 2;
        // }
        // console.log(a);
        // console.log(b);

        // {
        //     let a = 1;
        //     {
        //         let b = 1;
        //         console.log(a);
        //     }
        // }

        // 使用let 、const声明的变量 不能再被重新声明
        // let a = 1;
        // let a;
        // console.log(a); // Uncaught SyntaxError: Identifier 'a' has already been declared

        // let 不存在变量提升

        // 暂存死区
        // let a = 1;
        // {   
        //     // 如果快级作用域中存在let、const声明的变量（同名），那么会行程封闭的作用域
        //     console.log(a); // Uncaught ReferenceError: Cannot access 'a' before initialization
        //     let a = 2;
        // }
        // console.log(a);

        // const 常量必须在声明的时候赋值
        // 与let的区别 不可改变
        // 引用类型可以被修改
        // const xiaoming ={
        //     age:14,
        //     sex:"boy"
        // };
        // console.log(xiaoming);
        // xiaoming.age = 21;
        // console.log(xiaoming);
        // xiaoming={};    // Uncaught TypeError: Assignment to constant variable.

        // 防止引用类型被修改
        // Object.freeze()
        // const xiaoming ={
        //     age:14,
        //     sex:"boy"
        // };
        // Object.freeze(xiaoming);
        // console.log(xiaoming);
        // xiaoming.age = 21;
        // console.log(xiaoming);

        // ES6之前是怎样添加常量的？
        // var CST = {};
        // Object.defineProperty(CST, 'NMAE', {
        //     value: 'xiaoming',
        //     writable: false // 修改为只读
        // })
        // Object.seal(CST); // 防止内容被拓展

        // 封装
        // Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
        /*
        Object.defineProperty(Object, 'freezePolyfill', {
            value: function (obj) {
                var i;
                for (i in obj) {
                    // hasOwnProperty 判断是否自身的属性
                    if (obj.hasOwnProperty(i)) {
                        Object.defineProperty(obj, i, {
                            writable: false
                        });
                    }
                }
                // 如果内部还有｛｝，则需要一个递归函数 问题是怎么写？
                Object.seal(obj);
            }
        })
        */
        // const xiaoming = {
        //     age: 14,
        //     sex: "boy",
        //     a:{}
        // };
        // Object.freezePolyfill(xiaoming);
        // console.log(xiaoming);
        // xiaoming.age = 21;
        // xiaoming.a = 1;
        // console.log(xiaoming);
    </script>
    <!-- 解构、赋值 -->
    <script>
        
    </script>
</body>

</html>